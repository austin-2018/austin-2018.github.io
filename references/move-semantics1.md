#### C++ Rvalue references and move semantics
#### https://stackoverflow.com/questions/9498381/c-rvalue-references-and-move-semantics

##### EXCERPT
###### Because classes in Java and C# use reference semantics, there are never any implicit copies of objects in those languages. The problem move semantics solve does not and has never existed in Java and C#.


###### C++ can also use reference semantics. Infact, copy constructors are almost always written such that they take constant references. So the problem doesn't seem to do anything with references. – MetallicPriest Feb 29 '12 at 11:49 
10
###### "Passing by reference" and "reference semantics" are two different things. – fredoverflow Feb 29 '12 at 11:50
What is the difference? – MetallicPriest Feb 29 '12 at 11:54
In C#, structs have value semantics and classes have reference semantics. Also in C#, if you want to pass by reference, you use the ref qualifier. Without the ref qualifier, you get call by value. Both concepts are completely orthogonal: You can pass struct types by value or by reference, and you can pass class types by value or by reference. – fredoverflow Feb 29 '12 at 11:57
###### FredOverflow. I already know that C# passes copies of object references. And you can use ref or out to pass reference of reference. – MetallicPriest Feb 29 '12 at 12:07
###### FredOverflow - Say if you have operator overloading based Mathematical vector class and you use it like this in C#, "vector_a = vector_b + vector_c". How will C# achieve that without copying? The compiler will surely tranlsate vector_b + vector_c to some temperory (lets call it vector_tmp) and then assign it to vector_a, right? So ya, there will be some copying involved there? What C++11 do here is that through rvalue references, it allows the compiler to access vector_tmp as a reference, which is impossible in C++03, due to the fact that rvalues cannot be referenced in it. – MetallicPriest Feb 29 '12 at 12:51 
###### @MetallicPriest Yes and the whole "copying" that will happen in both Java and C# in that situation (assuming a class in c#) is the assignment of a reference to vector_a (which you need anyhow in c++ as well). In your given example there will never be more than 3 objects involved (and possibly less if vector_b and vector_c are the same object or + returns an existing object). rvals are a solution for a c++ problem that doesn't even exist in other languages to begin with.. – Voo Feb 29 '12 at 13:08 
###### @Voo, I totally disagree with you. I think you didn't understand the purpose of rvalues and move semantics. C# has no way to know if an object is a temporary rvalue or an lvalue. So, for example if you have vector_a = vector_b, there you do need to copy vector_b data to vector_a, but for expression, vector_a = vector_b + vector_c, you know that vector_tmp (=vector_b + vector_c) is a temporary rvalue, whose pointer to data can just be forwarded to vector_a, therefore no copying is required in C++11. C# can't differentiate the two and therefore you would need to copy data in both cases. – MetallicPriest Feb 29 '12 at 13:16 
###### @MetallicPriest Sadly I do understand rvals, not much around with the new standard. b2t: vector_b + vector_c is syntactic sugar for something like vector add(vector x, vector y). In the simplest case we create a new object and return a reference to it. You can think of this returned reference to the object as your vector_tmp. The only thing that happens afterwards is that we assign the reference to a local variable. There's no concept of copy constructors or assignment operators in Java or C# (at least not for the compiler). – Voo Feb 29 '12 at 13:25 
###### Basically it boils down to the fact that as its heart C++ is a value passing language (mostly because that makes the whole concept of who owns what object and who is responsible for the memory pretty simple), but sadly that has some rather large overhead - rvals remedy that to some degree. Both Java and C# take the opposite approach, so there's nothing to be gained from having rvals. The largest thing that can be passed around in Java (and c# ignoring structs) is 8byte in size (a pointer to an object) – Voo Feb 29 '12 at 13:31 
###### @Voo - Ah I see, I didn't know that C# doesn't allow overloading an assignment operator. Perhaps they avoided it just for this reason. – MetallicPriest Feb 29 '12 at 13:32 
###### @Voo - But wait a minute. What would C# behave for an expression like this, va + vb + vc + vd. Like you said it will create a new object on each addition, which can be avoided by using C+11 move semantics. I mean the same temporary object can be used for addition again and again, Like vt = vc + vd, then vt += vb and finally va += vt. While in C# you would have something like this, vt1 = vc + vd, vt2 = vt1 + vb and then va += vt2. – MetallicPriest Feb 29 '12 at 13:45 
###### @Metallic I wouldn't be using operators there (because of completely different semantics in all 3 involved languages), but instead functions. And then yes, you can make a function that returns a new object in C# - but you can just as well make a function that mutates a given object (which is what += in C++ does). – Voo Feb 29 '12 at 14:44



